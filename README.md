# Not Lua

Ever wanted to write Lua programs in... not Lua? Well, you're in the
right place! Now you can also write them in Nix!

features:
- it accidentally looks like lisp
- first-class Neovim support
- that's about it?

limitations:
- many (probably)

Simple examples: see [checks](./checks.nix).

Complex examples: see [my neovim
config](https://github.com/chayleaf/dotfiles/blob/master/home/common/nvim.nix)

To use this, add `notlua.nixosModules.${system}.default` to your config,
and then access it via `config.notlua`.

`notlua.utils` contains various functions, out of which you should only
really care about `compile`. It takes a module name (which will be used
to prefix variables, so you can put multiple modules in a single .lua
file), and the expression/statements to compile to lua.

`notlua.keywords` contains various keywords for writing the programs:

- `RAW <code>`: escape raw Lua code
- `PROP <expression> <name>`: get a property of `<expression>` with a
  name `<name>` (must be a string)
- `CALL`: call a function. Arguments are variadic, i.e. if you want to
  call `print(1, 2)` you do `CALL print 1 2`.
- `APPLY`: apply a list of arguments to a function (so you can do `APPLY
  (CALL print) [1 2]`)
- `MCALL`: call a method (`table:method()`). First argument is the
  table, second is method name, other arguments are passed to the
  function.
- `SET`: sets something to something (the `=` statement)
- `NOT`: not operator
- `EQ` `GE` `LE` `GT` `LT` `NE` `AND` `OR` - logical operators
- `ADD` `SUB` `MUL` `DIV` - arithmetic operators
- All operators take a variable amount of arguments, just like
  functions!
- There's probably many more operators you can add via `OP2` (`OP2 "=="`
  is the same as `EQ`, etc)
- `FORIN` - iterate over an iterator with a callback (first argument:
  iterator, second argument: callback).
  Example: `FORIN (CALL pairs table) (k: v: CALL print k v)`
- `RETURN` - return an expression
- `DEFUN` - create a zero argument function with provided body.
- `IF` - if condition. Syntax: `IF <cond1> <branch1> <cond2> <branch2>
  <fallback branch>`, or `IF <cond1> <branch1> <cond2> <branch2> ELSE
  <fallback branch>` (those are equivalent)
- `ATTR` - dynamically get a table's value (the `[]` operator)
- `LET` - create a local variable and call a callback with it.
  Example: `LET 1 2 3 (one: two: three: CALL print (ADD 1 2))`
- `LETREC`: same, but instead of expressions you provide functions that
  take the variables and generate the expressions. Example: the fifth
  fibonacci number:
  ```lua
  LETREC
    (fib:
      (n:
        IF (LT n 2)
          (RETURN n)
        ELSE
          (RETURN (ADD (fib (SUB n 1)) (fib (SUB n 2))))))
    (fib: PRINT (fib 5))
  ```
- `MACRO`: call a custom callback with internal transpiler state, the
  callback must return an attrset with values `result` (expression to
  compile) and `state` (new parser state).

Additionally, statement lists compile to one statement per line,
expression lists and attrsets compile to tables. Functions compile to
function expressions. You can even pass functions with attrset
parameters to the compiler: `({ a, b, c }: d: CALL print a b c d)` will
result in:

```lua
function(arg1, arg2)
  print(arg1.a, arg1.b, arg1.c, arg2)
end
```

There are autogenerated bindings for convenient interaction with Lua or
Neovim. They are available at `notlua.neovim { neovim-unwrapped,
plugins, extraLuaPackages }` and `notlua.lua { lua }` (all attributes
are optional). It exposes two modules - `stdlib` and `keywords`.
`stdlib` contains the default functions (such as `print` and `require`),
and `keywords` provides `REQ` (a version of `stdlib.require` that also
autogenerates bindings) and `REQLET` (a version of `LET` for requiring
modules while preserving type info), as well as `REQLET'` while gets
type info from running an expression in a fresh Lua interpreter (so you
can e.g. get type info of complex modules that involve metatables or
whatever).

Not that this means you don't have to do `CALL print a b` like I wrote
above, just `print a b` is enough! However, if a function has zero
arguments, or if you want to call a table, you will still have to use
`CALL`.

The bindings are type-aware and will not let you call a function with a
wrong argument count or set a Vim option to a wrong type (or any
other module's value, for that matter). There is currently no way to
disable the checks (but maybe Nix provides a way to ignore assertions?)

Since I only use this for configuring Neovim, there are likely many Lua
features might not be available (for example, you can't generate tables
with both numeric and keyword keys).

